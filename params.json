{
  "name": "Performancetesting",
  "tagline": "",
  "body": "# Performance testing workshop\r\nEver wondered how fast your code actually is or how \"good\" a certain algorithm solves a problem compared to an other.\r\n\r\n> \"Trust is good, but control is better.\" (Vladimir Lenin)\r\n\r\nMeasuring the actual performance of code can be difficult to do. In addition, more often than not, it required changes to the business logic to enable the measuring in the first place.\r\n\r\n## The Problem\r\nI want to measure how often a function is called or how long a method call takes.\r\n**But:** I don't want to modify my existing business logic. This problem is called \"Cross-cutting concern\".\r\n\r\n## Scenario\r\nLet's think about a scenario here. You have an existing webservice that does some heavy computations. As more and more users access this service, the responses get slow. You want to find out what is taking so long.\r\n\r\n**Solution: Logging**\r\n\r\n## Step 1\r\nLets assume we have this webservice.\r\n\r\n```java\r\nimport java.util.Random;\r\n\r\npublic class AwesomeWebService {\r\n\r\n    private final Random random;\r\n\r\n    public AwesomeWebService() {\r\n        random = new Random();\r\n    }\r\n\r\n    public int getAwesomeData() {\r\n        int runs = random.nextInt(300);\r\n        for (int i = 0; i < runs; i++) {\r\n            //Simulate expensive method\r\n            try {\r\n                Thread.sleep(random.nextInt(10) + 5);\r\n            } catch (InterruptedException ex) {\r\n            }\r\n        }\r\n        int result = random.nextInt();\r\n        System.out.println(\"result = \" + result);\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class Main {\r\n\r\n    public static void main(String[] args) {\r\n        AwesomeWebService webService = new AwesomeWebService();\r\n        webService.getAwesomeData();\r\n    }\r\n}\r\n```\r\nCreate a maven project with these classes in whatever editor you like and run the main **several times**. Notice that the total time it takes to run can vary from 0 to ~ 4 seconds.\r\n\r\n## Step 2\r\nNow try to find out why sometimes it takes up to 3 times as long. These lines could help.\r\n\r\n```java\r\n\tprivate int expensiveMethodCounter;\r\n\texpensiveMethodCounter++;\r\n\tSystem.out.println(\"Expensive method ran \" + expensiveMethodCounter + \" times.\");\r\n```\r\n\r\nWe now identified that there is some code which is called quite often sometimes and can take a long time.\r\n\r\nHowever, we modified the actual source code of the implementation in order to allow this.\r\n**-> Not desired**\r\n\r\n## Aspect oriented programming (AOP)\r\nAspect oriented programming is a mechanism of separating cross-cutting concerns. It allows to add additional behavior to existing code, without modifying the code itself.\r\n\r\n\r\n## Step 3\r\nNow, because we have created a Maven project in Step 1, we can make use of some magic. (Not actual magic, but Maven)\r\n\r\n* Delete the three lines added in Step 2\r\n* Add the following Maven dependencies to the POM file:\r\n\r\n```xml\r\n<dependencies>\r\n  <dependency>\r\n      <groupId>org.springframework</groupId>\r\n      <artifactId>spring-aop</artifactId>\r\n      <version>4.3.3.RELEASE</version>\r\n  </dependency>\r\n  <dependency>\r\n      <groupId>org.springframework</groupId>\r\n      <artifactId>spring-context</artifactId>\r\n      <version>4.3.3.RELEASE</version>\r\n  </dependency>\r\n  <dependency>\r\n      <groupId>org.springframework</groupId>\r\n      <artifactId>spring-core</artifactId>\r\n      <version>4.3.3.RELEASE</version>\r\n  </dependency>\r\n  <dependency>\r\n      <groupId>cglib</groupId>\r\n      <artifactId>cglib</artifactId>\r\n      <version>3.2.4</version>\r\n  </dependency>\r\n  <dependency>\r\n      <groupId>org.aspectj</groupId>\r\n      <artifactId>aspectjrt</artifactId>\r\n      <version>1.8.9</version>\r\n  </dependency>\r\n  <dependency>\r\n      <groupId>org.aspectj</groupId>\r\n      <artifactId>aspectjweaver</artifactId>\r\n      <version>1.8.9</version>\r\n  </dependency>\r\n</dependencies>\r\n```\r\n\r\n* Build project with dependencies\r\n* Create a folder called `resources` in `<projectRoot>/src/main/`\r\n* Create an XML file `context.xml` in this folder\r\n* Give it this content:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n\thttp://www.springframework.org/schema/beans/spring-beans-3.0.xsd\r\n\thttp://www.springframework.org/schema/aop\r\n\thttp://www.springframework.org/schema/aop/spring-aop-3.0.xsd \">\r\n\r\n    <aop:aspectj-autoproxy />\r\n\r\n    <bean id=\"awesomeWebService\" class=\"packagename.AwesomeWebService\"/>\r\n\r\n    <!-- Aspect -->\r\n    <bean id=\"loggingAspect\" class=\"logging.LoggingAspect\"/>\r\n</beans>\r\n```\r\n\r\n* Replace `packagename` with the name of your actual package\r\n* Create a package called `logging` in `Source packages`\r\n* Create a class called `LoggingAspect` in the `logging` package\r\n\r\nNow you have the basic setup to start using AOP.\r\n\r\n## Step 4\r\nNow we will make use of the spring AOP framework that we just added via Maven.\r\n\r\n##### Main class\r\n* Add `ApplicationContext appContext = new ClassPathXmlApplicationContext(\"context.xml\");` as the first line in the main method\r\n\t* Replace example with the name of your XML file\r\n* Now we have to get the bean that knows about AOP and use it as our webservice\r\n* Replace the constructor call of `AwesomeWebService` with `appContext.getBean(\"awesomeWebService\");` and cast the result to an `AwesomeWebService`\r\n\r\n\r\n##### LoggingAspect class\r\n* Import these packages in `LoggingAspect`.\r\n\r\n```java\r\nimport org.aspectj.lang.annotation.*;\r\n```\r\n\r\n* Annotate the class with `@Aspect`\r\n* Create `public void logBeforeGetAwesomeData()`\r\n* Annotate this method with `@Before(\"execution(* packagename.AwesomeWebService.getAwesomeData(..))\")`\r\n\t* Replace package name with the name of your actual package\r\n* Now you can write some logging in the `logBeforeGetAwesomeData ` method\r\n* It should appear in the console before the result of `AwesomeWebService.getAwesomeData`\r\n\r\n* Add a similar annotation (think about the annotation keyword to use) to a new method `public void logAfterGetAwesomeData()`\r\n* See when logging of this method appears in the console\r\n\r\nWe can use these two methods to measure how long a method executes. Just start a timer in the `Before` and stop it in the `After`. Try it out!\r\n\r\n\r\n## Step 5\r\nThis all sounds a bit complicated. Is there an easier way of doing this?\r\nYes there is.\r\n\r\n* Create `public Object logAroundGetAwesomeData() throws Throwable`\r\n* Annotate it as the before and after (think about the annotation keyword to use)\r\n* Add `ProceedingJoinPoint joinPoint` as a parameter\r\n* The before and after functionality is split by the line `joinPoint.proceed();`\r\n\t* Store the result of this on an `Object result` and return this at the end of the function\r\n\t* Think about why it throws a `Throwable`?\r\n  * Catch the `Throwable`, make sure your business logic continues (stop timers, log message) and then rethrow the exception\r\n\t* Think about what `result` contains?\r\n* Implement the same time-logging as you did with the two separate functions at the end of Step 4 (and uncomment them to prevent log diarrhea &#9786; )\r\n\r\n## Step 6 (Advanced)\r\nThis is fine for measuring and testing one method. It also allows for more sophisticated things like measuring how often a method has been executed. But there is one limitation to this.\r\n\r\nLet's assume we extend our webservice with a method that does some more elaborate calculations and fetches more data, etc. It could look something like this:\r\n\r\n```java\r\npublic void magicMethod() {\r\n  //magical things happen here\r\n  try {\r\n    Thread.sleep(random.nextInt(10) + 5);\r\n  } catch (InterruptedException ex) {\r\n  }\r\n}\r\n```\r\n\r\nWhich we would use like this in our `getAwesomeData`\r\n\r\n```java\r\nfor (int i = 0; i < runs; i++) {\r\n  //Simulate expensive method\r\n  magicMethod();\r\n}\r\n```\r\n\r\nIf we now want to also log and measure the `magicMethod`, we will run into some problems. In the `main` method, we defined our bean which is aware of the AOP and call the `getAwesomeData` method on this bean. This bean acts as a proxy to our actual `AwesomeWebService` object and allows the magic of AOP to happen.\r\n\r\nCalling a method as `magicMethod();` is logically the same as calling it as `this.magicMethod()`. Because this is the case, we can not easily use AOP on a method that is called inside another method. This is because the proxy bean is not the same as `this` inside the `AwesomeWebService`.\r\n\r\nSo in order to allow AOP to work with methods that are called by other methods, we need to delegate the method call to the proxy as well. Not nice because strictly speaking, we now modify the business logic. But at least the code is now not being polluted as much as with the earlier solution.\r\n\r\nIn order to use this, we need to add a proxy to the `AwesomeWebService`.\r\n\r\n```java\r\nprivate AwesomeWebService proxy = this;\r\n```\r\n\r\nThe next step is to replace the virtual `this` with the proxy object when calling functions.\r\n\r\n```java\r\nfor (int i = 0; i < runs; i++) {\r\n  //Simulate expensive method\r\n  proxy.magicMethod();\r\n}\r\n```\r\n\r\nThe last step is to set the proxy Object in the `main` method.\r\n\r\n```java\r\nwebService.setProxy(webService);\r\n```\r\nNow we can add `before`, `after`, etc. methods for `magicMethod` in the `LoggingAspect`.\r\nThe only thing we need to change is the parameter of the annotation to use the new method instead.\r\n\r\n**Task:** Build a mechanism for counting how often `magicMethod` has been executed.\r\n\r\n---\r\n\r\n#### Limitations\r\n> If your interception needs include protected/private methods or even constructors, consider the use of Spring-driven native AspectJ weaving instead of Spring's proxy-based AOP framework. This constitutes a different mode of AOP usage with different characteristics, so be sure to make yourself familiar with weaving first before making a decision.\r\n\r\nThis means unfortunately private methods are not supported with the Spring framework and more sophisticated means are required.\r\n\r\n---\r\n##### ALDA project\r\nThe NetBeans project for Mr. van Odenhoven can be found [here](https://www.fontysvenlo.org/svnp/2310309/sortingPerformance).\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}